#项目端口：8080 前端端口修改为8080 去进行访问
server.port=8080

#不再需要使用jsp 则此时下面进行注释掉
#配置前端展示使用JSP，因为springboot内部就是 spring+spring mvc
#spring.mvc.view.prefix=/
#spring.mvc.view.suffix=.jsp

#这边不需要进行连接数据库，所以以下进行注释掉
##需要连接数据库, 连接一个数据库，这个时候没有连接多个数据库，仅连接一个；一般情况下一个微服务就连接一个数据库
#spring.datasource.username=root
#spring.datasource.password=Iamegg816448
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/goodsdb?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC

#没有使用得到redis，将redis进行注释掉
#配置redis的连接信息
#spring.redis.host=127.0.0.1
#spring.redis.port=6379
#spring.redis.password=

#自己的starter
#spring.cat.redis.host=
#spring.cat.redis.port=
#spring.cat.redis.password=


#暴露端点 的该内容可以先留在这里
#打开所有的web访问端点
management.endpoints.web.exposure.include=*


#===================================================================================================
# eureka client向eureka server注册中心注册服务步骤：第二步配置文件

#消费者spring应用名称
#用于在Eureka注册中心当中首页HOME的Application表格，Application该列下该栏取值的配置
spring.application.name=34-springcloud-service-portal

#每间隔两秒，向服务端发送一次心跳，证明自己依然“存活”
eureka.instance.lease-renewal-interval-in-seconds=2

#告诉服务端，如果我十秒之内没有给你发送心跳，就代表我故障了，将我踢出掉
eureka.instance.lease-expiration-duration-in-seconds=10

# 此处出现机器名在于 http://127.0.0.1:8761/ 首页HOME当中的
#DS Replicas - Instances currently registered with Eureka下的表格中Application  AMIs    Availability Zones     Status当中
# Status下的链接，鼠标上移，出现的链接为：http://laptop-8nlb8jbf:9100/actuator/info
# 这当中的laptop-8nlb8jbf 即为机器名称，即下面选项如果为false,默认配置为false，
# 如果没有进行配置则是机器名代替了ip，如果配置为true即为 http://192.168.1.9:9100/actuator/info
# 告诉服务端，服务实例以IP作为链接，而不是机器名
eureka.instance.prefer-ip-address=true

#告诉服务端，服务实例的名字
#用于在Eureka注册中心首页当中Application该表格当中的Status列下取值的配置；此服务id 必须要唯一，不能重复；如果说重复的话，比如goods9100和goods9200进行了重复的话，那么就将会发生覆盖；由于通过集群的方式进行部署goods服务，并且部署了两份，如果两份都一样的话，那么启动第二个服务的时候就将会把第一个服务给覆盖掉，到时候再去看到Eureka注册中心首页的Application表格的Status列下就只有一个服务了
#且AMIs 的取值 n/a(2) 取值以及Availability Zones的取值(2)，Status列下的UP(2)就不再是2了，而是1，只有一个，后面的那一个会覆盖掉前面的那一个（如果服务id一样的话）所以需要保证服务id的唯一，不可重复；
#而spring.application.name 用于 goods9100和goods9200时需要保持一致
eureka.instance.instance-id=34-springcloud-service-portal


# eureka注册中心的连接地址
#eureka.client.service-url.defaultZone=http://localhost:8761/eureka
#eureka.client.service-url.defaultZone=http://eureka8761:8761/eureka,http://eureka8762:8762/eureka,http://eureka8763:8763/eureka
#本机的eureka server将不再启动，使用linux环境上部署好的eureka server高可用集群，连接linux上的eureka server，linux环境ip为：192.168.227.128
eureka.client.service-url.defaultZone=http://192.168.227.128:8761/eureka,http://192.168.227.128:8762/eureka,http://192.168.227.128:8763/eureka

# 本机的两台goods服务以及portal前端项目启动之后，清一下控制台的日志；再进行测试调用
# 即依然还是服务消费者去调用服务提供者的接口，所以测试地址为：http://localhost:8080/cloud/goods，由于目前是部署了两台goods服务的，一台goods是9100，另外一台是9200；
# 这个使用进行调用的是使用了@LoadBalanced注解的restTemplate，也就是说在调用过程中会使用到负载均衡，并不确定调用的是goods9100还是goods9200服务
# 在测试之前确保本地数据库是打开的（net start mysql）。访问测试地址返回响应数据:{"statusCode":0,"statusMessage":"查询成功","data":[{"id":1,"name":"商品1","price":67.0,"store":12},{"id":2,"name":"商品2","price":168.0,"store":1},{"id":3,"name":"商品3","price":25.0,"store":50}]}
# 此时观察 goods9100和goods9200的控制台，发现goods9200的控制台有打印信息：9200 被执行...............................
# 重复在浏览器地址栏多刷新几次测试地址：http://localhost:8080/cloud/goods，会发现goods9100和goods9200的控制台都有服务被执行的打印信息；
# 9100 被执行...............................、9200 被执行...............................
# 即两个服务都有被调用到，是通过ribbon的负载均衡算法实现的调用。因为此时存在有两个服务提供者goods9100和goods9200，集成了ribbon、eureka、restTemplate的注解@LoadBalanced注解进行了负载均衡调用
# 在dubbo当中也可以进行负载均衡调用，在dubbo标签当中可以进行配置一下即可以实现负载均衡的调用；而在spring cloud当中也可以实现负载均衡的调用，是通过ribbon去进行实现负载均衡调用的
# 通过ribbon测试负载均衡调用到此就测试结束

# 看到注册中心：http://192.168.227.128:8763/ 访问页面当中的Instances currently registered with Eureka下方的表格Application此时存在有服务实例即goods以及portal服务（34-SPRINGCLOUD-SERVICE-GOODS	、34-SPRINGCLOUD-SERVICE-PORTAL	）
# 服务提供者以及服务消费者都往linux当中的eureka server进行注册了服务，可以看到Application该表格当中的Status栏下方，goods服务存在有两份，分别是goods9100和goods9200（Application	AMIs	Availability Zones	Status | 34-SPRINGCLOUD-SERVICE-GOODS	n/a (2)	(2)	UP (2) - 34-springcloud-service-goods-9200 , 34-springcloud-service-goods-9100）
# 在Application和Status这两列的取值中Application中的取值就是服务在application.properties中配置的spring.application.name的取值
# 而在Status该列下的
#Spring Cloud客户端ribbon 负载均衡策略分析


# hystrix.command.default.execution.timeout.enabled、hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 该配置项点不进去，idea没有提示
# spring-cloud-starter-netflix-hystrix 该starter不识别以下配置项，starter的解析方式不识别以下的配置项；但是以下配置项正常，不是错误，
# 也就是说配置项名称后面的execution.timeout.enabled和execution.isolation.thread.timeoutInMilliseconds是可以通过搜索从而查询到的
# execution.timeout.enabled在 HystrixPropertiesManager.java该类当中可以查看得到，以及类HystrixCommandProperties.java该类当中也可以查看得到
# 该类com.netflix.hystrix.HystrixCommandProperties.java在hystrix-core jar包当中定义了[ this.executionTimeoutEnabled = getProperty(propertyPrefix, key, "execution.timeout.enabled", builder.getExecutionTimeoutEnabled(), default_executionTimeoutEnabled); ]
# com.netflix.hystrix.contrib.javanica.conf.HystrixPropertiesManager.java该类在hystrix-javanica jar中定义了[ public static final String EXECUTION_TIMEOUT_ENABLED = "execution.timeout.enabled"; ]
# 下面这两个配置项中 execution.timeout.enabled和execution.isolation.thread.timeoutInMilliseconds是可以在还有hystrix的相关jar包当中找到的
# 在上面这个两个execution配置项前需要加上前缀 即：hystrix.command.default.,而execution往后的配置项即为后缀，后缀在hystrix相关jar中可以找到
# 即hystrix命令默认配置：执行超时时间是否可用，默认取值是可用的即true；hystrix.command.default.execution.timeout.enabled执行是否启用超时，默认启用true，默认是启动的，即该行配置不配置也可以。
#hystrix.command.default.execution.timeout.enabled=true

# 指定hystrix的默认超时时长。execution.isolation.thread.timeoutInMilliseconds超时时间定义当前为5秒
#设置该两个配置项之后，再进行测试是否起作用，也就是客户端portal服务中的休眠两秒钟或者远程服务当中休眠的两秒钟测试。即服务中即便沉睡了两秒钟，但是hystrix此时的默认超时时间为5秒钟，即依然是可以响应给前端正常数据的。
#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=5000

#hystrix通过设置了如上两个配置之后，依然会发现触发了服务降级，也就是说在远程服务goods9100和goods9200中进行沉睡休眠了两秒钟，而此处配置修改了hystrix的默认超时时间为5秒钟不管用，测试访问地址响应得到的数据依然是fallback方法返回的默认值
#坑：如果 hystrix.command.default.execution.timeout.enabled为true，则会有两个执行方法超时的配置，一个就是 ribbon的 ReadTimeout（读取超时），一个就是熔断器 Hystrix 的timeoutInMilliseconds，此时谁的值小 谁生效；
#如果 `hystrix.command.default.execution.timeout.enabled`为 `false`，则熔断器不进行 超时熔断，而是根据 `ribbon`的 `ReadTimeout`抛出的异常而熔断，也就是取决于 `ribbon`的 `ConnectTimeout`，配置的是请求服务的超时时间，除非服务找不到 或者 网络原因 这个时间才会生效。
#所以也就是说如果想要上述配置生效即hystrix超时时间改为5秒钟，首先会先去看ribbon当中的 ReadTimeout (读取超时)配置项的取值，这个ribbon当中的ReadTimeout的取值看完之后才会去看到此时配置的hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds的取值
#这两个配置项的取值谁更小，就以谁为准。此时根据测试来看，ribbon的ReadTimeout没有5秒钟。
#所以在配置hystrix的默认超时时间时还需要进行配置Ribbon的ReadTimeout配置项取值。需要将Ribbon的ReadTimeout配置项取值配置得比hystrix默认超时时间配置项取值大，这个时候才会去取到hystrix默认超时时间配置项的取值

#ribbon.ReadTimeout 为ribbon的操作时间；ribbon除了有读取超时ReadTimeout还有连接超时ConnectTimeout
#ribbon.ReadTimeout 默认取值也是1秒，即默认读取操作时间为1秒，ribbon读取超时是1秒，当中访问的时候也是1秒；所以在上述配置完成之后进行测试访问地址时很快就返回了fallback当中的默认数据（没有卡顿很快出结果）。因为当时ribbon的ReadTimeout为1秒，hystrix经过配置之后取的是5秒，然而以小的取值生效，则hystrix依然还是使用的超时时间为1秒，所以返回fallback数据给前端比较快
#ribbon. 点后面的内容发现点不出来，即idea没有ReadTimeout的相关提示。而ribbon进行配置ReadTimeout配置项即直接在ribbon.后面加上ReadTimeout即可
ribbon.ReadTimeout=6000
ribbon.ConnectTimeout=3000
#此时由于ribbon的ReadTimeout取值为6秒，显然是大于上面hystrix配置默认超时时间的5秒的。所以这个时候再进行测试就会取到hystrix配置默认超时时间配置项的取值。
#也就是说 hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=5000 该配置就会生效

#配置完Ribbon的ReadTimeout以及ConnectTimeout配置项取值之后再进行重新编译一下portal服务，portal会自动重新部署，重启完成之后即可再次测试访问 http://localhost:8080/cloud/goodsHystrix
#则此时响应数据如下:{"statusCode":0,"statusMessage":"查询成功","data":[{"id":1,"name":"商品1","price":67.0,"store":12},{"id":2,"name":"商品2","price":168.0,"store":1},{"id":3,"name":"商品3","price":25.0,"store":50}]}
#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds配置项取值生效只和ribbon的ReadTimeout配置项取值有关，谁的值小取谁的值。
#通过此时的响应数据可以知道，hystrix配置取值修改生效，没有因为远程服务的休眠两秒钟而触发hystrix的服务降级，因为hystrix的超时响应时间已经被改为5秒钟了。




