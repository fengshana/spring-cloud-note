#项目端口：8080 前端端口修改为8080 去进行访问
server.port=8080

#不再需要使用jsp 则此时下面进行注释掉
#配置前端展示使用JSP，因为springboot内部就是 spring+spring mvc
#spring.mvc.view.prefix=/
#spring.mvc.view.suffix=.jsp

#这边不需要进行连接数据库，所以以下进行注释掉
##需要连接数据库, 连接一个数据库，这个时候没有连接多个数据库，仅连接一个；一般情况下一个微服务就连接一个数据库
#spring.datasource.username=root
#spring.datasource.password=Iamegg816448
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/goodsdb?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC

#没有使用得到redis，将redis进行注释掉
#配置redis的连接信息
#spring.redis.host=127.0.0.1
#spring.redis.port=6379
#spring.redis.password=

#自己的starter
#spring.cat.redis.host=
#spring.cat.redis.port=
#spring.cat.redis.password=


#暴露端点 的该内容可以先留在这里
#打开所有的web访问端点
management.endpoints.web.exposure.include=*


#===================================================================================================
# eureka client向eureka server注册中心注册服务步骤：第二步配置文件

#消费者spring应用名称
#用于在Eureka注册中心当中首页HOME的Application表格，Application该列下该栏取值的配置
spring.application.name=34-springcloud-service-portal

#每间隔两秒，向服务端发送一次心跳，证明自己依然“存活”
eureka.instance.lease-renewal-interval-in-seconds=2

#告诉服务端，如果我十秒之内没有给你发送心跳，就代表我故障了，将我踢出掉
eureka.instance.lease-expiration-duration-in-seconds=10

# 此处出现机器名在于 http://127.0.0.1:8761/ 首页HOME当中的
#DS Replicas - Instances currently registered with Eureka下的表格中Application  AMIs    Availability Zones     Status当中
# Status下的链接，鼠标上移，出现的链接为：http://laptop-8nlb8jbf:9100/actuator/info
# 这当中的laptop-8nlb8jbf 即为机器名称，即下面选项如果为false,默认配置为false，
# 如果没有进行配置则是机器名代替了ip，如果配置为true即为 http://192.168.1.9:9100/actuator/info
# 告诉服务端，服务实例以IP作为链接，而不是机器名
eureka.instance.prefer-ip-address=true

#告诉服务端，服务实例的名字
#用于在Eureka注册中心首页当中Application该表格当中的Status列下取值的配置；此服务id 必须要唯一，不能重复；如果说重复的话，比如goods9100和goods9200进行了重复的话，那么就将会发生覆盖；由于通过集群的方式进行部署goods服务，并且部署了两份，如果两份都一样的话，那么启动第二个服务的时候就将会把第一个服务给覆盖掉，到时候再去看到Eureka注册中心首页的Application表格的Status列下就只有一个服务了
#且AMIs 的取值 n/a(2) 取值以及Availability Zones的取值(2)，Status列下的UP(2)就不再是2了，而是1，只有一个，后面的那一个会覆盖掉前面的那一个（如果服务id一样的话）所以需要保证服务id的唯一，不可重复；
#而spring.application.name 用于 goods9100和goods9200时需要保持一致
eureka.instance.instance-id=34-springcloud-service-portal


# eureka注册中心的连接地址
#eureka.client.service-url.defaultZone=http://localhost:8761/eureka
#eureka.client.service-url.defaultZone=http://eureka8761:8761/eureka,http://eureka8762:8762/eureka,http://eureka8763:8763/eureka
#本机的eureka server将不再启动，使用linux环境上部署好的eureka server高可用集群，连接linux上的eureka server，linux环境ip为：192.168.227.128
eureka.client.service-url.defaultZone=http://192.168.227.128:8761/eureka,http://192.168.227.128:8762/eureka,http://192.168.227.128:8763/eureka

# 本机的两台goods服务以及portal前端项目启动之后，清一下控制台的日志；再进行测试调用
# 即依然还是服务消费者去调用服务提供者的接口，所以测试地址为：http://localhost:8080/cloud/goods，由于目前是部署了两台goods服务的，一台goods是9100，另外一台是9200；
# 这个使用进行调用的是使用了@LoadBalanced注解的restTemplate，也就是说在调用过程中会使用到负载均衡，并不确定调用的是goods9100还是goods9200服务
# 在测试之前确保本地数据库是打开的（net start mysql）。访问测试地址返回响应数据:{"statusCode":0,"statusMessage":"查询成功","data":[{"id":1,"name":"商品1","price":67.0,"store":12},{"id":2,"name":"商品2","price":168.0,"store":1},{"id":3,"name":"商品3","price":25.0,"store":50}]}
# 此时观察 goods9100和goods9200的控制台，发现goods9200的控制台有打印信息：9200 被执行...............................
# 重复在浏览器地址栏多刷新几次测试地址：http://localhost:8080/cloud/goods，会发现goods9100和goods9200的控制台都有服务被执行的打印信息；
# 9100 被执行...............................、9200 被执行...............................
# 即两个服务都有被调用到，是通过ribbon的负载均衡算法实现的调用。因为此时存在有两个服务提供者goods9100和goods9200，集成了ribbon、eureka、restTemplate的注解@LoadBalanced注解进行了负载均衡调用
# 在dubbo当中也可以进行负载均衡调用，在dubbo标签当中可以进行配置一下即可以实现负载均衡的调用；而在spring cloud当中也可以实现负载均衡的调用，是通过ribbon去进行实现负载均衡调用的
# 通过ribbon测试负载均衡调用到此就测试结束

# 看到注册中心：http://192.168.227.128:8763/ 访问页面当中的Instances currently registered with Eureka下方的表格Application此时存在有服务实例即goods以及portal服务（34-SPRINGCLOUD-SERVICE-GOODS	、34-SPRINGCLOUD-SERVICE-PORTAL	）
# 服务提供者以及服务消费者都往linux当中的eureka server进行注册了服务，可以看到Application该表格当中的Status栏下方，goods服务存在有两份，分别是goods9100和goods9200（Application	AMIs	Availability Zones	Status | 34-SPRINGCLOUD-SERVICE-GOODS	n/a (2)	(2)	UP (2) - 34-springcloud-service-goods-9200 , 34-springcloud-service-goods-9100）
# 在Application和Status这两列的取值中Application中的取值就是服务在application.properties中配置的spring.application.name的取值
# 而在Status该列下的
#Spring Cloud客户端ribbon 负载均衡策略分析










