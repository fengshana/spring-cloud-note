# 进行配置eureka注册中心高可用集群，现在通过多文件环境配置的方式进行搭建三台eureka注册中心服务，三台eureka端口分别为8761、8762、8763
# 分别修改各自eureka server服务的端口号；server.port=876X
# 且第一台eureka要向另外两台eureka注册自己的服务，即通过eureka.client.service-url.defaultZone去指定另外两台eureka server的服务地址
# 即eureka.client.service-url.defaultZone=http://eureka8762:8762/eureka,http://eureka8763:8763/eureka
# 相当于自己该服务作为后端，通过这两个注册中心给予的地址去向其中注册自己的服务；另外这两个地址即8762和8763给予的服务注册中心的路径
# 当前端口为 8761，则本身应该去连接 8762和8763的注册中心eureka，即eureka.client.service-url.defaultZone=http://localhost:8762/eureka，http://localhost:8763/eureka
# 存在有多个注册中心地址，用英文逗号分隔开即可。
# 使用了application-eureka8761.properties、application-eureka8762.properties、application-eureka8763.properties之后，
# application.properties就不再使用了，使用上述三个文件即可

#在application.properties 该核心文件当中指定一下内嵌tomcat端口是多少
#内嵌定死tomcat 的端口
server.port=8761

# 服务的hostname，本地的 localhost
#设置该服务注册中心的 hostname
eureka.instance.hostname=localhost

# register-with-eureka 注册使用Eureka
# 因为 eureka-server 该项目本身也是一个微服务，spingboot开发的项目web应用，微服务；那么这个微服务的话会默认自己向自己进行注册
# 修改为false的原因在于，自己只是作为注册中心，自己并不代表其他服务，不代表服务提供者或者服务消费者，所以不要将自己本身 注册中心 往注册中心也就是自己 进行注册
# 应该是可以理解为 自己该服务并不提供业务服务出去也不会进行消费业务服务，
# 由于我们目前创建的应用是一个 服务注册中心，而不是普通的应用，默认情况下，这个应用会向注册中心（也是它自己）注册它自己
# 设置为false，表示禁止这种 自己向自己注册的默认行为
eureka.client.register-with-eureka=false

# 修改为false 即 不要去检查其他服务，由于自己本身就是注册中心，不用去检索其他服务
# fetch 获取
# 表示不去从服务端 检索 其他服务信息，因为自己就是服务端，服务注册中心本身的职责就是维护服务实例，它不需要去检索其他服务
# 即不需要去订阅其他的服务，去发现其他的服务
eureka.client.fetch-registry=false

# 也就是注册中心的路径，可以理解为对外提供的注册接口的地址
# 即http://eureka.instance.hostname + : + eureka-server.server.port + /eureka
# 表示注册中心到时候提供的服务是这个接口地址，其他子服务 通过这个接口地址向注册中心注册服务即可，它就可以接应到
# eureka-server本身也提供了对外的一个接口，然后其他子服务 往这个接口去进行注册即可，对外暴露该接口，然后其余子服务向该接口注册服务即可
# 指定服务注册中心的位置
#eureka.client.service-url.defaultZone=http://localhost:8761/eureka
#向另外两台eureka server注册中心服务注册自己的服务；同理8762则往8761和8763注册中心进行注册服务，8763往8761和8762注册中心进行注册服务
#eureka.client.service-url.defaultZone=http://localhost:8762/eureka,http://localhost:8763/eureka
#由于在 hosts 文件当中进行修改了名称即 127.0.0.1 eureka8761 这种形式，所以以下可以进行替换;将其余两个application-eureka876X.properties同时进行修改，将localhost都改为eureka8761
#eureka.client.service-url.defaultZone=http://eureka8761:8762/eureka,http://eureka8761:8763/eureka 错误
eureka.client.service-url.defaultZone=http://eureka8762:8762/eureka,http://eureka8763:8763/eureka
# 三台eureka注册中心的浏览器地址为 http://localhost:8761、http://localhost:8762、http://localhost:8763，这三台eureka服务就构成了一个集群，每一个eureka server注册中心都可以进行访问
# 每一个eureka server服务相当于无中心master的，没有主从的概念。即无中心master的注册中心。没有主没有从没有leader这样的角色概念。
# 在http://localhost:8761、http://localhost:8762、http://localhost:8763 的HOME 主页中可以看到DS Replicas下全部都显示的是eureka8761，
# 而应该eureka8761对应显示的是eureka8762和eureka8763,eureka8762对应应该要显示的是eureka8761和eureka8763，eureka8763对应应该要显示的是eureka8761和eureka8762，而现在没有对应显示出来，那么应该是有一点问题的
# 目前三台eureka server注册中心是搭建完成了，查看还有什么漏掉的步骤
# 错误在于这三个配置文件中eureka.client.service-url.defaultZone当中取值的host name都是eureka8761所以显示的时候都是eureka8761，
# 这里需要将对应的哪一个端口就修改成对应的eureka+端口号（eureka8761、eureka8762、eureka8763）这三个host name都是在hosts文件当中配置过了的，这三个host name都是代表了ip，即127.0.0.1、localhost
# 这里不同的端口号对应着不同的host name应该是为了做更好的区分是哪一台eureka服务，
# 猜测：即如果不做区分的话，那么DS Replicas可能都将显示的是同一个值即127.0.0.1或者localhost?
# 也就是说eureka server那边页面显示就显示host name 或者ip 不会显示具体的端口，从而也不知道DS Replicas数据源复制到了哪一个eureka server注册中心上了
# 以上进行修改完成之后就对应上了，两两注册，也就是每个eureka server除去自身另外的两台eureka server, 即http://localhost:8761/的DS Replicas下显示的是eureka8762、eureka8763，http://localhost:8762/的DS Replicas下显示的是eureka8761、eureka8763，http://localhost:8763/的DS Replicas下显示的是eureka8761、eureka8762
# DS Replicas 表示数据源的复制，Data Source; 当前集群已经完成，可以启动GoodsAppliation以及PortalApplication服务提供者服务以及服务消费者服务，可以看到在这三个eureka server上都有看到goods和portal服务的注册信息
# (上面出现goods和portal的两个服务注册信息时，goods和portal的application.properties中的eureka.client.service-url.defaultZone并没有修改，即还是原来的取值，三个eureka server注册中心都出现了这两个服务的注册信息，猜测可能是由于集群间会发生复制的缘故)
# 在goods服务和portal服务的application.properties当中的eureka.client.service-url.defaultZone也需要修改成三份
# 即eureka.client.service-url.defaultZone=http://eureka8761:8761/eureka,http://eureka8762:8762/eureka，http://eureka8763:8763/eureka
# 在goods和portal服务中的application.properties的eureka.client.service-url.defaultZone中连接了三个服务注册中心地址，就和zookeeper一样，zookeeper集群也是连接了三个地址，逗号分隔，在dubbo当中也是如此
# 所以和dubbo很多地方有相似之处，eureka也是走远程调用，只不过该远程调用是走restful api风格http的，然而dubbo是使用RPC，dubbo协议进行调用，底层走的是netty，netty调用，这是他们之间的一个区别
# 从整体宏观来看，两者非常相似
# goods和portal服务的application.properties的eureka.client.service-url.defaultZone修改完成之后，重新启动这两个服务，发现三个eureka server的Application上有这两个服务的注册信息
# http://localhost:8761,http://localhost:8762，http://localhost:8763 这三个eureka server看完之后，再测试下服务消费者调用服务提供者也就是portal调用goods服务，访问地址还是一样，只不过其中的注册中心使用到了的是集群的方式，之前是单个eureka server
# portal服务调用goods服务的时候，portal服务中的application.properties中eureka.client.service-url.defaultZone也是指向的这三个eureka server地址，就像消费端；zookeeper，就像原来学习dubbo一样，dubbo当中的zookeeper集群，那么消费者和服务提供者都需要将地址改成三个ip+端口，逗号进行分隔。
# 测试地址：http://localhost:8080/cloud/goods
# 在测试之前可以看下其本身goods服务，服务本身也是一个rest 服务，所以通过 http://localhost:9100/service/goods 也是可以进行访问的；返回结果如下：{"statusCode":0,"statusMessage":"查询成功","data":[{"id":1,"name":"商品1","price":67.00,"store":12},{"id":2,"name":"商品2","price":168.00,"store":1},{"id":3,"name":"商品3","price":25.00,"store":50}]}
# 服务者本身访问自己没有问题，那么消费者去调用服务者这个时候也是没有问题的；调用返回响应结果如下：{"statusCode":0,"statusMessage":"查询成功","data":[{"id":1,"name":"商品1","price":67.0,"store":12},{"id":2,"name":"商品2","price":168.0,"store":1},{"id":3,"name":"商品3","price":25.0,"store":50}]}

# 可以使用dubbo调用eureka中的服务吗？
# 目前没有直接的使用方法，写代码的话也是可以的包装一下，基于eureka的ip 接口，eureka也是java代码去编写的，dubbo需要和eureka适配一下，目前没有；如果要这么使用的话，可以使用Spring Cloud Alibaba
# Spring Cloud Alibaba有一套微服务生态，它里面有Nacos注册中心，Dubbo可以往Nacos当中进行注册服务，Nacos有点类似于Eureka；Spring Cloud Alibaba当中还有Sentinel，服务限流降级组件，有点类似于Spring Cloud当中的...
# Spring Cloud Alibaba还有自己的RocketMQ，消息队列，消息服务器


# 一般情况下配置如上
# eureka.  后面会有很多的配置信息，有一些配置存在有默认值，
# springboot当中不管集成什么，都会有一大堆这样类似的配置；不需要每一个配置都去看一遍，使用一些常用的即可
# 上述配置完成之后，进行启动与测试 Eureka 服务注册中心
# 1. 完成上面的项目搭建后，我们就可以启动springboot程序， main方法运行
# 2. 启动成功之后，通过在浏览器地址栏访问我们的注册中心；


