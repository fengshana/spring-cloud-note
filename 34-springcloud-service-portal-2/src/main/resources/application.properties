#项目端口：8080 前端端口修改为8080 去进行访问
#消费者2号不与1号撞端口号
server.port=8081

#不再需要使用jsp 则此时下面进行注释掉
#配置前端展示使用JSP，因为springboot内部就是 spring+spring mvc
#spring.mvc.view.prefix=/
#spring.mvc.view.suffix=.jsp

#这边不需要进行连接数据库，所以以下进行注释掉
##需要连接数据库, 连接一个数据库，这个时候没有连接多个数据库，仅连接一个；一般情况下一个微服务就连接一个数据库
#spring.datasource.username=root
#spring.datasource.password=Iamegg816448
#spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
#spring.datasource.url=jdbc:mysql://127.0.0.1:3306/goodsdb?useSSL=false&useUnicode=true&characterEncoding=UTF-8&serverTimezone=UTC

#没有使用得到redis，将redis进行注释掉
#配置redis的连接信息
#spring.redis.host=127.0.0.1
#spring.redis.port=6379
#spring.redis.password=

#自己的starter
#spring.cat.redis.host=
#spring.cat.redis.port=
#spring.cat.redis.password=


#配置文件需要配置springboot监控端点的访问权限，hystrix dashboard仪表盘监控 使用了hystrix服务的项目中hystrix的运行情况时需要进行配置的内容
#该端点是actuator的端点，也可以使用这种方式即：management.endpoints.web.exposure.include=hystrix.stream，即包含hystrix.stream即可
#暴露端点 的该内容可以先留在这里
#打开所有的web访问端点
#management.endpoints.web.exposure.include=*
management.endpoints.web.exposure.include=hystrix.stream
#在配置完服务消费者中的pom.xml添加好spring-cloud-starter-netflix-hystrix依赖以及spring-boot-starter-actuator依赖之后，以及配置application.properties中暴露端点配置项之后
# 即可重启服务重新启动服务不通过热部署插件进行重启
# 注意management.endpoints.web.exposure.include 该配置项不要把单词写错否则将造成以下访问地址无法访问；重新启动portal消费者服务rebuild
#测试访问地址：http://localhost:8080/actuator/hystrix.stream 响应如下（将一直出现ping: ........一直在ping:......）
#ping:
#
#ping:
#
#ping:
#
#ping:
#
#注意：
#
#这里有一个细节需要注意，要访问/hystrix.stream接口，首先得访问comsumer工程中的任意一个其他接口，否则直接访问/hystrix.stream接口时会输出一连串的ping:ping:......，先访问consumer中的任意一个其他接口，然后再访问/hystrix.stream接口即可；
#先进行访问 http://localhost:8080/cloud/goodsFeignHystrix 或者 http://localhost:8080/cloud/goodsHystrix 一个是调用远程服务异常后进行了服务降级另外一个是直接将异常抛出到了前端浏览器页面当中
#虽然调用其他接口出现了异常但是也算访问了其他接口的意思，再次访问http://localhost:8080/actuator/hystrix.stream，将响应如下:
#data: {"type":"HystrixCommand","name":"GoodsRemoteClient#goods()","group":"34-SPRINGCLOUD-SERVICE-GOODS","currentTime":1622104932967,"isCircuitBreakerOpen":false,"errorPercentage":0,"errorCount":0,"requestCount":0,"rollingCountBadRequests":0,"rollingCountCollapsedRequests":0,"rollingCountEmit":0,"rollingCountExceptionsThrown":0,"rollingCountFailure":0,"rollingCountFallbackEmit":0,"rollingCountFallbackFailure":0,"rollingCountFallbackMissing":0,"rollingCountFallbackRejection":0,"rollingCountFallbackSuccess":0,"rollingCountResponsesFromCache":0,"rollingCountSemaphoreRejected":0,"rollingCountShortCircuited":0,"rollingCountSuccess":0,"rollingCountThreadPoolRejected":0,"rollingCountTimeout":0,"currentConcurrentExecutionCount":0,"rollingMaxConcurrentExecutionCount":0,"latencyExecute_mean":0,"latencyExecute":{"0":0,"25":0,"50":0,"75":0,"90":0,"95":0,"99":0,"99.5":0,"100":0},"latencyTotal_mean":0,"latencyTotal":{"0":0,"25":0,"50":0,"75":0,"90":0,"95":0,"99":0,"99.5":0,"100":0},"propertyValue_circuitBreakerRequestVolumeThreshold":20,"propertyValue_circuitBreakerSleepWindowInMilliseconds":5000,"propertyValue_circuitBreakerErrorThresholdPercentage":50,"propertyValue_circuitBreakerForceOpen":false,"propertyValue_circuitBreakerForceClosed":false,"propertyValue_circuitBreakerEnabled":true,"propertyValue_executionIsolationStrategy":"THREAD","propertyValue_executionIsolationThreadTimeoutInMilliseconds":1000,"propertyValue_executionTimeoutInMilliseconds":1000,"propertyValue_executionIsolationThreadInterruptOnTimeout":true,"propertyValue_executionIsolationThreadPoolKeyOverride":null,"propertyValue_executionIsolationSemaphoreMaxConcurrentRequests":10,"propertyValue_fallbackIsolationSemaphoreMaxConcurrentRequests":10,"propertyValue_metricsRollingStatisticalWindowInMilliseconds":10000,"propertyValue_requestCacheEnabled":true,"propertyValue_requestLogEnabled":true,"reportingHosts":1,"threadPool":"34-SPRINGCLOUD-SERVICE-GOODS"}
#该为当前消费者服务拿到了这样一个数据，即以上的数据，这个数据很多并且还在不断的新增，这个数据放在浏览器页面当中可读性并不好，它是一个JSON数据
#将该地址http://localhost:8080/actuator/hystrix.stream在http://localhost:3721/hystrix首页中的【http://hostname:port/turbine/turbine.stream】该文本框中键入，然后点击按钮【Monitor Stream】
#然后该dashboard将读取该接口当中的信息并且对其进行监控，仪表盘当中的内容即为点击【Monitor Stream】按钮进去跳转的页面







#===================================================================================================
# eureka client向eureka server注册中心注册服务步骤：第二步配置文件

#消费者spring应用名称
#用于在Eureka注册中心当中首页HOME的Application表格，Application该列下该栏取值的配置
spring.application.name=34-springcloud-service-portal-2

#每间隔两秒，向服务端发送一次心跳，证明自己依然“存活”
eureka.instance.lease-renewal-interval-in-seconds=2

#告诉服务端，如果我十秒之内没有给你发送心跳，就代表我故障了，将我踢出掉
eureka.instance.lease-expiration-duration-in-seconds=10

# 此处出现机器名在于 http://127.0.0.1:8761/ 首页HOME当中的
#DS Replicas - Instances currently registered with Eureka下的表格中Application  AMIs    Availability Zones     Status当中
# Status下的链接，鼠标上移，出现的链接为：http://laptop-8nlb8jbf:9100/actuator/info
# 这当中的laptop-8nlb8jbf 即为机器名称，即下面选项如果为false,默认配置为false，
# 如果没有进行配置则是机器名代替了ip，如果配置为true即为 http://192.168.1.9:9100/actuator/info
# 告诉服务端，服务实例以IP作为链接，而不是机器名
eureka.instance.prefer-ip-address=true

#告诉服务端，服务实例的名字
#用于在Eureka注册中心首页当中Application该表格当中的Status列下取值的配置；此服务id 必须要唯一，不能重复；如果说重复的话，比如goods9100和goods9200进行了重复的话，那么就将会发生覆盖；由于通过集群的方式进行部署goods服务，并且部署了两份，如果两份都一样的话，那么启动第二个服务的时候就将会把第一个服务给覆盖掉，到时候再去看到Eureka注册中心首页的Application表格的Status列下就只有一个服务了
#且AMIs 的取值 n/a(2) 取值以及Availability Zones的取值(2)，Status列下的UP(2)就不再是2了，而是1，只有一个，后面的那一个会覆盖掉前面的那一个（如果服务id一样的话）所以需要保证服务id的唯一，不可重复；
#而spring.application.name 用于 goods9100和goods9200时需要保持一致
eureka.instance.instance-id=34-springcloud-service-portal-2


# eureka注册中心的连接地址
#eureka.client.service-url.defaultZone=http://localhost:8761/eureka
#eureka.client.service-url.defaultZone=http://eureka8761:8761/eureka,http://eureka8762:8762/eureka,http://eureka8763:8763/eureka
#本机的eureka server将不再启动，使用linux环境上部署好的eureka server高可用集群，连接linux上的eureka server，linux环境ip为：192.168.227.128 | 192.168.177.128
#eureka.client.service-url.defaultZone=http://192.168.227.128:8761/eureka,http://192.168.227.128:8762/eureka,http://192.168.227.128:8763/eureka
#eureka.client.service-url.defaultZone=http://192.168.177.128:8761/eureka,http://192.168.177.128:8762/eureka,http://192.168.177.128:8763/eureka
eureka.client.service-url.defaultZone=http://192.168.177.129:8761/eureka,http://192.168.177.129:8762/eureka,http://192.168.177.129:8763/eureka


# 本机的两台goods服务以及portal前端项目启动之后，清一下控制台的日志；再进行测试调用
# 即依然还是服务消费者去调用服务提供者的接口，所以测试地址为：http://localhost:8080/cloud/goods，由于目前是部署了两台goods服务的，一台goods是9100，另外一台是9200；
# 这个使用进行调用的是使用了@LoadBalanced注解的restTemplate，也就是说在调用过程中会使用到负载均衡，并不确定调用的是goods9100还是goods9200服务
# 在测试之前确保本地数据库是打开的（net start mysql）。访问测试地址返回响应数据:{"statusCode":0,"statusMessage":"查询成功","data":[{"id":1,"name":"商品1","price":67.0,"store":12},{"id":2,"name":"商品2","price":168.0,"store":1},{"id":3,"name":"商品3","price":25.0,"store":50}]}
# 此时观察 goods9100和goods9200的控制台，发现goods9200的控制台有打印信息：9200 被执行...............................
# 重复在浏览器地址栏多刷新几次测试地址：http://localhost:8080/cloud/goods，会发现goods9100和goods9200的控制台都有服务被执行的打印信息；
# 9100 被执行...............................、9200 被执行...............................
# 即两个服务都有被调用到，是通过ribbon的负载均衡算法实现的调用。因为此时存在有两个服务提供者goods9100和goods9200，集成了ribbon、eureka、restTemplate的注解@LoadBalanced注解进行了负载均衡调用
# 在dubbo当中也可以进行负载均衡调用，在dubbo标签当中可以进行配置一下即可以实现负载均衡的调用；而在spring cloud当中也可以实现负载均衡的调用，是通过ribbon去进行实现负载均衡调用的
# 通过ribbon测试负载均衡调用到此就测试结束

# 看到注册中心：http://192.168.227.128:8763/ 访问页面当中的Instances currently registered with Eureka下方的表格Application此时存在有服务实例即goods以及portal服务（34-SPRINGCLOUD-SERVICE-GOODS	、34-SPRINGCLOUD-SERVICE-PORTAL	）
# 服务提供者以及服务消费者都往linux当中的eureka server进行注册了服务，可以看到Application该表格当中的Status栏下方，goods服务存在有两份，分别是goods9100和goods9200（Application	AMIs	Availability Zones	Status | 34-SPRINGCLOUD-SERVICE-GOODS	n/a (2)	(2)	UP (2) - 34-springcloud-service-goods-9200 , 34-springcloud-service-goods-9100）
# 在Application和Status这两列的取值中Application中的取值就是服务在application.properties中配置的spring.application.name的取值
# 而在Status该列下的
#Spring Cloud客户端ribbon 负载均衡策略分析


# hystrix.command.default.execution.timeout.enabled、hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds 该配置项点不进去，idea没有提示
# spring-cloud-starter-netflix-hystrix 该starter不识别以下配置项，starter的解析方式不识别以下的配置项；但是以下配置项正常，不是错误，
# 也就是说配置项名称后面的execution.timeout.enabled和execution.isolation.thread.timeoutInMilliseconds是可以通过搜索从而查询到的
# execution.timeout.enabled在 HystrixPropertiesManager.java该类当中可以查看得到，以及类HystrixCommandProperties.java该类当中也可以查看得到
# 该类com.netflix.hystrix.HystrixCommandProperties.java在hystrix-core jar包当中定义了[ this.executionTimeoutEnabled = getProperty(propertyPrefix, key, "execution.timeout.enabled", builder.getExecutionTimeoutEnabled(), default_executionTimeoutEnabled); ]
# com.netflix.hystrix.contrib.javanica.conf.HystrixPropertiesManager.java该类在hystrix-javanica jar中定义了[ public static final String EXECUTION_TIMEOUT_ENABLED = "execution.timeout.enabled"; ]
# 下面这两个配置项中 execution.timeout.enabled和execution.isolation.thread.timeoutInMilliseconds是可以在还有hystrix的相关jar包当中找到的
# 在上面这个两个execution配置项前需要加上前缀 即：hystrix.command.default.,而execution往后的配置项即为后缀，后缀在hystrix相关jar中可以找到
# 即hystrix命令默认配置：执行超时时间是否可用，默认取值是可用的即true；hystrix.command.default.execution.timeout.enabled执行是否启用超时，默认启用true，默认是启动的，即该行配置不配置也可以。
#hystrix.command.default.execution.timeout.enabled=true

# 指定hystrix的默认超时时长。execution.isolation.thread.timeoutInMilliseconds超时时间定义当前为5秒
#设置该两个配置项之后，再进行测试是否起作用，也就是客户端portal服务中的休眠两秒钟或者远程服务当中休眠的两秒钟测试。即服务中即便沉睡了两秒钟，但是hystrix此时的默认超时时间为5秒钟，即依然是可以响应给前端正常数据的。
#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=5000

#hystrix通过设置了如上两个配置之后，依然会发现触发了服务降级，也就是说在远程服务goods9100和goods9200中进行沉睡休眠了两秒钟，而此处配置修改了hystrix的默认超时时间为5秒钟不管用，测试访问地址响应得到的数据依然是fallback方法返回的默认值
#坑：如果 hystrix.command.default.execution.timeout.enabled为true，则会有两个执行方法超时的配置，一个就是 ribbon的 ReadTimeout（读取超时），一个就是熔断器 Hystrix 的timeoutInMilliseconds，此时谁的值小 谁生效；
#如果 `hystrix.command.default.execution.timeout.enabled`为 `false`，则熔断器不进行 超时熔断，而是根据 `ribbon`的 `ReadTimeout`抛出的异常而熔断，也就是取决于 `ribbon`的 `ConnectTimeout`，配置的是请求服务的超时时间，除非服务找不到 或者 网络原因 这个时间才会生效。
#所以也就是说如果想要上述配置生效即hystrix超时时间改为5秒钟，首先会先去看ribbon当中的 ReadTimeout (读取超时)配置项的取值，这个ribbon当中的ReadTimeout的取值看完之后才会去看到此时配置的hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds的取值
#这两个配置项的取值谁更小，就以谁为准。此时根据测试来看，ribbon的ReadTimeout没有5秒钟。
#所以在配置hystrix的默认超时时间时还需要进行配置Ribbon的ReadTimeout配置项取值。需要将Ribbon的ReadTimeout配置项取值配置得比hystrix默认超时时间配置项取值大，这个时候才会去取到hystrix默认超时时间配置项的取值

#ribbon.ReadTimeout 为ribbon的操作时间；ribbon除了有读取超时ReadTimeout还有连接超时ConnectTimeout
#ribbon.ReadTimeout 默认取值也是1秒，即默认读取操作时间为1秒，ribbon读取超时是1秒，当中访问的时候也是1秒；所以在上述配置完成之后进行测试访问地址时很快就返回了fallback当中的默认数据（没有卡顿很快出结果）。因为当时ribbon的ReadTimeout为1秒，hystrix经过配置之后取的是5秒，然而以小的取值生效，则hystrix依然还是使用的超时时间为1秒，所以返回fallback数据给前端比较快
#ribbon. 点后面的内容发现点不出来，即idea没有ReadTimeout的相关提示。而ribbon进行配置ReadTimeout配置项即直接在ribbon.后面加上ReadTimeout即可
#ribbon.ReadTimeout=6000
#ribbon.ConnectTimeout=3000
#此时由于ribbon的ReadTimeout取值为6秒，显然是大于上面hystrix配置默认超时时间的5秒的。所以这个时候再进行测试就会取到hystrix配置默认超时时间配置项的取值。
#也就是说 hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds=5000 该配置就会生效

#配置完Ribbon的ReadTimeout以及ConnectTimeout配置项取值之后再进行重新编译一下portal服务，portal会自动重新部署，重启完成之后即可再次测试访问 http://localhost:8080/cloud/goodsHystrix
#则此时响应数据如下:{"statusCode":0,"statusMessage":"查询成功","data":[{"id":1,"name":"商品1","price":67.0,"store":12},{"id":2,"name":"商品2","price":168.0,"store":1},{"id":3,"name":"商品3","price":25.0,"store":50}]}
#hystrix.command.default.execution.isolation.thread.timeoutInMilliseconds配置项取值生效只和ribbon的ReadTimeout配置项取值有关，谁的值小取谁的值。
#通过此时的响应数据可以知道，hystrix配置取值修改生效，没有因为远程服务的休眠两秒钟而触发hystrix的服务降级，因为hystrix的超时响应时间已经被改为5秒钟了。


#此时，如果ribbon的ReadTimeout进行注释掉，不写的话就会触发服务降级即访问http://localhost:8080/cloud/goodsHystrix响应如下：{"statusCode":1,"statusMessage":"服务降级了","data":null}，
#远程服务沉睡2秒，goodsHystrix方法的注解中修改了hystrix的默认超时时间为5秒，在配置文件中注释掉了ribbon.ReadTimeout配置，仍然触发了服务降级。那么尽管在portal的controller goodsHystrix()方法中进行配置注解 @HystrixCommand的相关配置项配置了execution.isolation.thread.timeoutInMilliseconds是没有用的
#单独在配置文件或者是方法上的注解中配置好了hystrix的修改默认超时时间的配置是不会生效的还需要搭配 ribbon的ReadTimeout才会生效，且ribbon的ReadTimeout还需要比hystrix修改的默认超时时间要大才会生效
#将配置文件当中的ribbon.ReadTimeout配置项添加上之后再加上goodsHystrix的注解修改默认hystrix的超时时间，即使得hystrix修改默认超时时间生效，即rebuild重启portal服务后,重启完成portal服务后访问地址：http://localhost:8080/cloud/goodsHystrix 响应如下：{"statusCode":0,"statusMessage":"查询成功","data":[{"id":1,"name":"商品1","price":67.0,"store":12},{"id":2,"name":"商品2","price":168.0,"store":1},{"id":3,"name":"商品3","price":25.0,"store":50}]}
#即响应了正常数据没有服务降级，远程服务是沉睡两秒，而hystrix的默认超时时间是5秒，没有超时响应，即不会触发hystrix的服务降级
#所以不管在注解当中写hystrix的修改默认超时时间还是在配置文件application.properties中配置hystrix的默认超时时间都需要在application.properties中添加ribbon.ReadTimeout的配置信息



#默认在spring cloud dalston版本后就将其设置为false了，所以此时需要将其设置为true，
# 才能够测试feign整合hystrix，
# 将ribbon.ReadTimeout和execution.isolation.thread.timeoutInMilliseconds配置项注释之后，调用远程服务需要两秒钟而hystrix默认超时时间为1秒钟，没有去进行修改配置项则默认超时时间为1秒钟。
# 此时调用远程服务超时，需要通过注解@FeignClient中的配置项fallback GoodsRemoteClientFallBack类当中的goods()服务降级方法返回给前端
# 如果只在代码层当中@FeignClient配置了fallback为GoodsRemoteClientFallBack类的话将不会触发hystrix服务降级，因为feign.hystrix.enabled没有进行配置为true。
# 没有开启则该通过feign整合hystrix 触发服务降级的功能无法使用；feign.hystrix.enabled默认取值为false
# If true,an OpenFeign client will be wrapped with a Hystrix circuit 如果该配置项取值为true，那么该hystrix将会去包装hystrix的熔断；如果不是true则不会进行包装；默认为false
#再次重新编译portal服务重新启动并访问 http://localhost:8080/cloud/goodsFeignHystrix 响应如下：{"statusCode":1,"statusMessage":"feign 服务调用降级","data":null}
# 响应内容当中的statusMessage为：feign 服务调用降级 即调用到了GoodsRemoteClientFallBack类当中的goods()服务降级方法；这就是通过@FeignClient注解配置项fallback，由于远程服务超时从而调用服务降级类当中的服务降级方法。
# 所以application.properties文件当中进行开启feign.hystrix.enable的配置以及在@FeignClient注解也就是GoodsRemoteClient的接口上的@FeignClient注解中配置配置项fallback GoodsRemoteClientFallBack中来做服务降级操作
feign.hystrix.enabled=true
#之前是在portal服务当中的controller中去做的服务降级即在goodsHystrix方法上注解@HystrixCommand中配置项fallbackMethod方法配置fallback()方法 从而实现服务降级
#而当前的goodsFeignHystrix方法上则不再需要@HystrixCommand注解以及其配置项fallbackMethod了，只有一个spring mvc的@RequestMapping注解的路径，
# 因为feign接口GoodsRemoteClient接口当中@FeignClient注解配置项fallback已经帮其配置了服务降级类，GoodsRemoteClientFallBack 类，而该类实现了GoodsRemoteClient接口，重写了goods()方法，该类即为专门的服务降级类，重写的goods方法即专门的服务降级方法
# 因为当前是在feign声明式服务调用的接口上@FeignClient注解中配置项fallback去做了服务降级的配置
# 即@FeignClient(value = "34-SPRINGCLOUD-SERVICE-GOODS", fallback = GoodsRemoteClientFallBack.class)
# 以上即通过配置项feign.hystrix.enabled配置以及@FeignClient 配置项fallback的配置 这种方式来将feign和hystrix结合起来去使用
# 注意需要将feign.hystrix.enabled进行开启，默认是关闭的，如果不开启则@FeignClient尽管配置了fallback都没有用。





















